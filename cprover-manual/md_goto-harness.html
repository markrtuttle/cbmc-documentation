<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CProver manual: goto-harness</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CProver manual
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">goto-harness </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href=".">CPROVER Manual TOC</a></p>
<h1><a class="anchor" id="autotoc_md121"></a>
Goto Harness</h1>
<p>This is a tool for generating harnesses, that is, functions that instrument another function under analysis, by setting up an appropriate environment before calling them.</p>
<p>This is useful when trying to analyse an isolated unit of a program without having to manually construct an appropriate environment.</p>
<h2><a class="anchor" id="autotoc_md122"></a>
Quick Start Guide</h2>
<p>For a given C program - <code>program.c</code> - to generate a harness for a function <code>test_function</code>, we have to do the following:</p>
<p><code>sh # Compile the program $ goto-cc program.c -o program.gb # Run goto-harness to produce harness file $ goto-harness --harness-type call-function --harness-function-name generated_harness_test_function --function test_function program.gb harness.c # Run the checks targetting the generated harness $ cbmc --pointer-check harness.c program.c --function generated_harness_test_function</code></p>
<h2><a class="anchor" id="autotoc_md123"></a>
Detailed Usage</h2>
<p>We have two types of harnesses we can generate for now:</p>
<ul>
<li>The <code>function-call</code> harness, which automatically synthesises an environment without having any information about the program state.</li>
<li>The <code>memory-snapshot</code> harness, which loads an existing program state (in form of a JSON file) and selectively <em>havoc-ing</em> some variables.</li>
</ul>
<p>The harness generator can either produce the harness (i.e., the function environment) as C code, or a full GOTO binary. C code is generated when the output file name ends in ".c".</p>
<h3><a class="anchor" id="autotoc_md124"></a>
The function call harness generator</h3>
<p>For the most basic use of the <code>function-call</code> harness generator, imagine that we have the following C program:</p>
<p>``` C // main.c</p>
<h1><a class="anchor" id="autotoc_md125"></a>
include &lt;assert.h&gt;</h1>
<p>int function_to_test(int some_argument) { assert(some_argument == 0); return some_argument; } ```</p>
<p>We first need to generate a GOTO binary.</p>
<p><code>sh $ goto-cc -o main.gb main.c</code></p>
<p>Then we can call <code>goto-harness</code> on the generated GOTO binary to get a new C file that contains the harness function:</p>
<p><code>sh $ goto-harness \ --harness-function-name harness \ --harness-type call-function \ --function function_to_test \ main.gb \ harness.c</code></p>
<p>The options we pass to <code>goto-harness</code> are:</p>
<ul>
<li><code>harness-function-name</code> is the name of the function generated by the harness generator (this needs to be specified for all harness generators).</li>
<li><code>harness-type</code> is the type of harness to generate (<code>call-function</code> is the function-call harness generator)</li>
<li><code>function</code> is the name of the function that gets instrumented</li>
<li>then we pass the input GOTO-binary and a name for the output C file.</li>
</ul>
<p>What comes out of this is a C file that looks like this:</p>
<p>```C // function_to_test // file main.c line 3 signed int function_to_test(signed int some_argument); // harness // void harness(void); // type_constructor_int // void type_constructor_int(signed int depth_int, signed int *result_int);</p>
<p>// __GOTO_HARNESS::max_depth // file __GOTO_HARNESSharness.c signed int max_depth=2; // __GOTO_HARNESS::min_depth // file __GOTO_HARNESSharness.c signed int min_depth=1;</p>
<p>// harness // void harness(void) { signed int some_argument; type_constructor_int(0, &amp;some_argument); function_to_test(some_argument); }</p>
<p>// type_constructor_int // void type_constructor_int(signed int depth_int, signed int *result_int) { signed int nondet; *result_int = nondet; } ```</p>
<p>After you have generated the harness file, you have two choices. The first one is to pass it along with the original file containing the function to be harnessed to CBMC for analysis, something that would look like this:</p>
<p>```sh $ cbmc &ndash;function harness harness.c main.c [...]</p>
<p>[function_to_test.assertion.1] line 5 assertion some_argument == 0: FAILURE</p>
<p>** 1 of 1 failed (2 iterations) VERIFICATION FAILED ```</p>
<p>Or, you could choose to turn it into another goto binary with <code>goto-cc</code>, to be served as input to another instrumentation tool (like <code>goto-instrument</code>).</p>
<hr  />
<p>The example above demonstrates the simplest case, which is roughly the same as the entry point <code>cbmc</code> automatically generates for functions. However, the <code>function-call</code> harness can also non-deterministically initialise global variables, array and struct elements. Consider this more complicated example:</p>
<p>```C // list_example.c</p>
<h1><a class="anchor" id="autotoc_md127"></a>
include &lt;assert.h&gt;</h1>
<h1><a class="anchor" id="autotoc_md128"></a>
include &lt;stdlib.h&gt;</h1>
<p>typedef struct linked_list linked_list; struct linked_list { int value; linked_list *next; };</p>
<p>linked_list *global_linked_list;</p>
<p>/// initialize all values in the global /// list to 0 void initialize_global(void) { for(linked_list *ll = global_linked_list; ll != NULL; ll = ll-&gt;next) { ll-&gt;value = 0; } }</p>
<p>/// try to initialize all values in the linked list /// to 0 - but this version contains two bugs, /// as it won't work with nullpointer arguments /// and it will also not initialize the last element void initialize_other(linked_list *ll) { do { ll-&gt;value = 0; ll = ll-&gt;next; } while(ll-&gt;next != NULL); }</p>
<p>void check_list(linked_list *list_parameter) { assert(list_parameter != global_linked_list); initialize_global(); initialize_other(list_parameter); linked_list *global_cursor = global_linked_list; linked_list *parameter_cursor = list_parameter; </p><pre class="fragment">// global list should be a prefix of the parameter now,
// or the other way round
while(global_cursor != NULL &amp;&amp; parameter_cursor != NULL)
{
    // this assertion should fail since we didn't
    // initialize the last element of of the
    // list parameter correctly
    assert(global_cursor-&gt;value
      == parameter_cursor-&gt;value);
    global_cursor = global_cursor-&gt;next;
    parameter_cursor = parameter_cursor-&gt;next;
}
</pre><p>} ```</p>
<p>Now we'll try to find the bug in <code>check_list</code> by generating a harness for it.</p>
<p><code>sh $ goto-cc -o list_example.gb list_example.c $ goto-harness \ --harness-function-name harness \ --harness-type call-function \ --function check_list \ --max-nondet-tree-depth 4 \ --min-null-tree-depth 1 \ --nondet-globals \ list_example.gb \ list_example_harness.c $ cbmc list_example.c list_example_harness.c --function harness --unwind 20 --unwinding-assertions</code></p>
<p>We have 3 new options here:</p>
<ul>
<li><code>max-nondet-tree-depth</code> is the maximum extent to which we will generate and initialize non-null pointers - in this case, this means generating lists up to length 4</li>
<li><code>min-null-tree-depth</code> this is the minimum depth at which pointers can be nullpointers for generated values - in this case, this sets the <em>minimum</em> length for our linked lists to one.</li>
<li><code>nondet-globals</code> is non-deterministically initialising global variables.</li>
</ul>
<p>``` CBMC version 5.11 (cbmc-5.11-1523-g419a958-dirty) 64-bit x86_64 linux [...]</p>
<p>** Results: example.c function initialize_global [initialize_global.unwind.0] line 17 unwinding assertion loop 0: SUCCESS</p>
<p>example.c function initialize_other [initialize_other.unwind.0] line 32 unwinding assertion loop 0: SUCCESS</p>
<p>example.c function check_list [check_list.assertion.1] line 42 assertion list_parameter != global_linked_list: SUCCESS [check_list.unwind.0] line 50 unwinding assertion loop 0: SUCCESS [check_list.assertion.2] line 55 assertion global_cursor-&gt;value == parameter_cursor-&gt;value: FAILURE</p>
<p>** 1 of 5 failed (2 iterations) VERIFICATION FAILED ```</p>
<p>We also have support for arrays (currently only for array function parameters, globals and struct members are considered for the future).</p>
<p>Take this example of an implementation of an <code>is_prefix_of</code> function that should return true if the first string parameter <code>prefix</code> is a prefix of the second one <code>string</code>.</p>
<p>```c // array_example.c</p>
<p>int is_prefix_of( const char *prefix, int prefix_length, const char *string, int string_length ) { if(prefix_length &gt; string_length) { return 0; } // oops, we should have used prefix_length here for(int i = 0; i &lt; string_length; ++i) { // we'll get an out of bounds error here! if(prefix[i] != string[i]) { return 0; } } return 1; } ```</p>
<p>We can compile and run it like this:</p>
<p><code>sh $ goto-cc -o array_example.gb array_example.c $ goto-harness \ --harness-function-name harness \ --harness-type call-function \ --function is_prefix_of \ --associated-array-size string:string_length \ --associated-array-size prefix:prefix_length \ array_example.gb array_example_harness.c $ cbmc --function harness --unwind 10 --pointer-check array_example_harness.c array_example.c</code></p>
<p>We have the additional option <code>associated-array-size</code> here. This is in the format <code>&lt;array-parameter-name&gt;:&lt;array-size-parameter-name&gt;</code> and will cause the array parameter with name<code>array-parameter-name</code> to be initialised as an array, with the parameter <code>array-size-parameter-name</code> holding its size (it should have some integral type like <code>int</code> or <code>size_t</code>).</p>
<p>Running the example shows the bug highlighted in the comments:</p>
<p><code>[...] [is_prefix_of.pointer_dereference.6] line 14 dereference failure: pointer outside object bounds in prefix[(signed long int)i]: FAILURE</code></p>
<p>By default, arrays are created with a minimum size of 1 and a maximum size of 2. These limits can be set with the <code>--min-array-size</code> and <code>--max-array-size</code> options.</p>
<p>If you have a function that takes an array parameter, but without an associated size parameter, you can also use the <code>--treat-pointer-as-array &lt;parameter-name&gt;</code> option.</p>
<hr  />
<p>If you want to non-deterministically initialise a pointer as a C string (character array with last element &lsquo;&rsquo;\0'`) then you can do that like this:</p>
<p>``` C // nondet_string.c</p>
<h1><a class="anchor" id="autotoc_md130"></a>
include &lt;assert.h&gt;</h1>
<p>void function(char *pointer, int size) { assert(pointer[size-1] == '\0'); } ```</p>
<p>Then call the following:</p>
<p><code>sh $ goto-cc -o nondet_string.gb nondet_string.c $ goto-harness \ --harness-function-name harness \ --harness-type call-function \ --function function \ --treat-pointer-as-cstring pointer \ --associated-array-size pointer:size \ nondet_string.gb nondet_string_harness.c $ cbmc --function harness nondet_string_harness.c nondet_string.c --unwind 10</code></p>
<p>Note that C strings are supported by the same mechanism behind the non-deterministic initialisation of pointers and arrays, so the same command line arguments apply, in particular <code>--associated-array-size</code>.</p>
<p>This will result in:</p>
<p>``` [...]</p>
<p>** Results: main.c function function [function.assertion.1] line 5 assertion pointer[size-1] == '\0': SUCCESS</p>
<p>** 0 of 1 failed (1 iterations) VERIFICATION SUCCESSFUL ```</p>
<h2><a class="anchor" id="autotoc_md131"></a>
The memory snapshot harness</h2>
<p>The <code>function-call</code> harness is used in situations in which we want to analyze a function in an arbitrary environment. If we want to analyze a function starting from a <em>real</em> program state, we can use the <code>memory-snapshot</code> harness instead.</p>
<p>The snapshot of the program state of interest may be taken at a particular program location within a function (using the <code>memory-analyzer</code> tool). In that case we want to generate a harness that behaves as if execution starts at a particular program location. The initial program location can be specified via the options <code>--initial-goto-location &lt;function&gt;[:&lt;location-number&gt;]</code> or <code>--initial-source-location &lt;file&gt;:&lt;line-number&gt;</code>.</p>
<p>Say we want to check the assertion in the following code:</p>
<p>```C // main.c</p>
<h1><a class="anchor" id="autotoc_md132"></a>
include &lt;assert.h&gt;</h1>
<h1><a class="anchor" id="autotoc_md133"></a>
include &lt;stdlib.h&gt;</h1>
<p>int x; int y; int z;</p>
<p>// complex function which returns 1 int get_one() { int i;</p>
<p>for(i = 0; i &lt; 100001; i++) { if(rand() &amp;&amp; ((i &amp; 1) == 1)) break; }</p>
<p>return i &amp; 1; }</p>
<p>// return a random value (!= 0) int get_random_value() { int r; while((r = rand()) == 0) {} return r; }</p>
<p>int clip(int i) { if(i &gt; 99) { i = 99; }</p>
<p>return i; }</p>
<p>int main() { x = get_random_value(); y = get_one();</p>
<p>// snapshot taken here (line 46)</p>
<p>z = clip(x);</p>
<p>assert(y + z &lt;= 100);</p>
<p>return 0; } ```</p>
<p>Assume we are interested in the code represented by the <code>clip()</code> function and its effect on the assertion below. To that end, we want to take a memory snapshot after the calls to <code>get_random_value()</code> and <code>get_one()</code>.</p>
<p>In order to take the snapshot with <code>memory-analyzer</code>, we need to first compile the program which <code>goto-gcc</code>, which produces a binary containing both native machine code and the corresponding goto program:</p>
<p><code>sh $ goto-gcc -g -o main.gb main.c</code></p>
<p>Then we can execute the program with <code>memory-analyzer</code> and take a snapshot at the specified breakpoint. The variables to be included in the snapshot need to be specified via the <code>--symbols</code> option.</p>
<p>&lsquo;sh $ memory-analyzer \ --breakpoint 46 \ --symbols 'x, y, z&rsquo; \ &ndash;symtab-snapshot \ &ndash;json-ui \ main.gb \ &gt; snapshot.json`</p>
<p>We then generate a harness with <code>goto-harness</code> that behaves as if execution started from the state given by the memory snapshot at the specified program location. We further overapproximate the value returned by <code>get_random_value()</code> by havocking the variable <code>x</code>.</p>
<p>```sh $ goto-cc -o main.gb main.c</p>
<p>$ goto-harness \ &ndash;harness-function-name harness \ &ndash;harness-type initialize-with-memory-snapshot \ &ndash;memory-snapshot snapshot.json \ &ndash;initial-source-location main.c:46 \ &ndash;havoc-variables x \ main.gb main-mod.gb ```</p>
<p>We can now verify the resulting goto program with <code>cbmc</code>:</p>
<p><code>sh $ cbmc --function harness main-mod.gb</code></p>
<p>This will result in:</p>
<p>``` [...]</p>
<p>** Results: main.c function main [main.assertion.1] line 50 assertion y + z &lt;= 100: SUCCESS</p>
<p>** 0 of 1 failed (1 iterations) VERIFICATION SUCCESSFUL ```</p>
<p>Last modified: 2022-09-21 19:02:04 -0400 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
