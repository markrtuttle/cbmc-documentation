<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CProver manual: contracts-functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CProver manual
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">contracts-functions </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href=".">CPROVER Manual TOC</a></p>
<h1><a class="anchor" id="autotoc_md57"></a>
Function Contracts</h1>
<p>CBMC offers support for function contracts, which includes three basic clauses: <em>requires</em>, <em>ensures</em>, and <em>assigns</em>. These clauses formally describe the specification of a function. CBMC also provides a series of built-in constructs to be used with functions contracts (e.g., <em>history variables</em>, <em>quantifiers</em>, and <em>memory predicates</em>).</p>
<p>When a function contract is checked, the tool automatically havocs all static variables of the program (to start the analysis in an arbitrary state), in the same way as using <code>--nondet-static</code> would do. If one wishes not to havoc some static variables, then <code>--nondet-static-exclude name-of-variable</code> can be used.</p>
<h2><a class="anchor" id="autotoc_md58"></a>
Overview</h2>
<p>Take a look at the example below.</p>
<p>```c</p>
<h1><a class="anchor" id="autotoc_md59"></a>
include &lt;stdlib.h&gt;</h1>
<h1><a class="anchor" id="autotoc_md60"></a>
include &lt;stdint.h&gt;</h1>
<h1><a class="anchor" id="autotoc_md61"></a>
define SUCCESS 0</h1>
<h1><a class="anchor" id="autotoc_md62"></a>
define FAILURE -1</h1>
<p>int sum(const uint32_t a, const uint32_t b, uint32_t* out) { const uint64_t result = ((uint64_t) a) + ((uint64_t) b); if (result &gt; UINT32_MAX) return FAILURE; *out = (uint32_t) result; return SUCCESS; }</p>
<p>int foo() { uint32_t a; uint32_t b; uint32_t out; int rval = sum(a, b, &amp;out); if (rval == SUCCESS) return out; return rval; } ```</p>
<p>Function <code>sum</code> writes the sum of <code>a</code> and <code>b</code> to <code>out</code>, and returns <code>SUCCESS</code>; unless the result of the addition is too large to be represented as an <code>uint32_t</code>, in which case it returns <code>FAILURE</code>. Let's write a function contract for this function.</p>
<p>A function contract has three parts:</p>
<ul>
<li><b>Precondition</b> - describes what the function requires of the arguments supplied by the caller and of global variables;</li>
<li><b>Postcondition</b> - describes the effect of the function;</li>
<li><b>Write Set</b> - describes the set of locations outside the function that might be written to.</li>
</ul>
<p>In our example, the developer may require from the caller to properly allocate all arguments, thus, pointers must be valid. We can specify the preconditions of a function using <code>__CPROVER_requires</code> (see <a class="el" href="md_contracts-requires-and-ensures.html">Requires \&amp; Ensures Clauses</a> for details) and we can specify an allocated object using a predicate called <code>__CPROVER_is_fresh</code> (see <a class="el" href="md_contracts-memory-predicates.html">Memory Predicate</a> for details). Thus, for the <code>sum</code> function, the set of preconditions are</p>
<p><code>c /* Precondition */ __CPROVER_requires(__CPROVER_is_fresh(out, sizeof(*out)))</code></p>
<p>We can use <code>__CPROVER_ensures</code> to specify postconditions (see <a class="el" href="md_contracts-requires-and-ensures.html">Requires \&amp; Ensures Clauses</a> for details). In our example, developers can use the built-in construct <code>__CPROVER_return_value</code>, which represents the return value of a function. As postconditions, one may list possible return values (in this case, either <code>SUCCESS</code> or <code>FAILURE</code>) as well as describe the main property of this function: if the function returns <code>SUCCESS</code>, then <code>*out</code> stores the result of <code>a + b</code>. We can also check that the value in <code>*out</code> will be preserved in case of failure by using <code>__CPROVER_old</code>, which refers to the value of a given object in the pre-state of a function (see <a class="el" href="md_contracts-history-variables.html">History Variables</a> for details). Thus, for the <code>sum</code> function, the set of postconditions are</p>
<p><code>c /* Postconditions */ __CPROVER_ensures(__CPROVER_return_value == SUCCESS || __CPROVER_return_value == FAILURE) __CPROVER_ensures((__CPROVER_return_value == SUCCESS) ==&gt; (*out == (a + b))) __CPROVER_ensures((__CPROVER_return_value == FAILURE) ==&gt; (*out == __CPROVER_old(*out)))</code></p>
<p>Finally, the <em>assigns</em> clause allows developers to define a frame condition (see <a class="el" href="md_contracts-assigns.html">Assigns Clause</a> for details). In general, systems for describing the frame condition of a function use either writes or modifies semantics; this design is based on the former. This means that memory not specified by the assigns clause must not be written within the given function scope, even if the value(s) therein are not modified. In our example, since we expect that only the value that <code>out</code> points to may be modified, we annotate the function using <code>__CPROVER_assigns(*out)</code>.</p>
<p><code>c /* Write Set */ __CPROVER_assigns(*out)</code></p>
<p>Here is the whole function with its contract.</p>
<p><code>c int sum(const uint32_t a, const uint32_t b, uint32_t* out) /* Precondition */ __CPROVER_requires(__CPROVER_is_fresh(out, sizeof(*out))) /* Postconditions */ __CPROVER_ensures(__CPROVER_return_value == SUCCESS || __CPROVER_return_value == FAILURE) __CPROVER_ensures((__CPROVER_return_value == SUCCESS) ==&gt; (*out == (a + b))) __CPROVER_ensures((__CPROVER_return_value == FAILURE) ==&gt; (*out == __CPROVER_old(*out))) /* Write Set */ __CPROVER_assigns(*out) { const uint64_t result = ((uint64_t) a) + ((uint64_t) b); if (result &gt; UINT32_MAX) return FAILURE; *out = (uint32_t) result; return SUCCESS; }</code></p>
<p>First, we have to prove that the function satisfies the contract.</p>
<p><code>shell goto-cc -o sum.goto *.c --function sum goto-instrument --enforce-contract sum sum.goto sum-checking-contracts.goto cbmc sum-checking-contracts.goto --function sum</code></p>
<p>The first command just compiles the GOTO program as usual, the second command instruments the code to check the function satisfies the contract, and the third one runs CBMC to do the checking.</p>
<p>Now that we have proved that the function satisfies the contract, we can use the function contract in place of the function implementation wherever the function is called.</p>
<p><code>shell goto-cc -o foo.goto *.c --function foo goto-instrument --replace-call-with-contract sum foo.goto foo-using-sum-contract.goto cbmc foo-using-sum-contract.goto --function foo</code></p>
<p>The first command just compiles the GOTO program as usual, the second command instruments the code to use the function contract in place of the function implementation wherever is invoked, and the third one runs CBMC to check the program using contracts.</p>
<h2><a class="anchor" id="autotoc_md63"></a>
Additional Resources</h2>
<ul>
<li><a class="el" href="md_contracts-requires-and-ensures.html">Requires \&amp; Ensures Clauses</a></li>
<li><a class="el" href="md_contracts-assigns.html">Assigns Clause</a></li>
<li><a class="el" href="md_contracts-memory-predicates.html">Memory Predicates</a></li>
<li><a class="el" href="md_contracts-history-variables.html">History Variables</a></li>
<li><a class="el" href="md_contracts-quantifiers.html">Quantifiers</a></li>
</ul>
<p>Last modified: 2022-09-21 19:02:04 -0400 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
