<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CProver manual: api</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CProver manual
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">api </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href=".">CPROVER Manual TOC</a></p>
<h2><a class="anchor" id="autotoc_md0"></a>
The CPROVER API Reference</h2>
<p>The following sections summarize the functions available to programs that are passed to the CPROVER tools.</p>
<h3><a class="anchor" id="autotoc_md1"></a>
Functions</h3>
<h4><a class="anchor" id="autotoc_md2"></a>
__CPROVER_assume, __CPROVER_assert, assert</h4>
<p><code>C void __CPROVER_assume(_Bool assumption); void __CPROVER_assert(_Bool assertion, const char *description); void assert(_Bool assertion);</code></p>
<p>The function **__CPROVER_assume** adds an expression as a constraint to the program. If the expression evaluates to false, the execution aborts without failure. More detail on the use of assumptions is in the section on <a class="el" href="md_modeling-assumptions.html">Assumptions</a>.</p>
<h4><a class="anchor" id="autotoc_md3"></a>
__CPROVER_input, __CPROVER_output</h4>
<p><code>C void __CPROVER_input(const char *id, ...); void __CPROVER_output(const char *id, ...);</code></p>
<p>The functions **__CPROVER_input** and **__CPROVER_output** are used to report an input or output value. Note that they do not generate input or output values. The first argument is a string constant to distinguish multiple inputs and outputs (inputs are typically generated using nondeterminism, as described <a class="el" href="md_modeling-nondeterminism.html">here</a>). The string constant is followed by an arbitrary number of values of arbitrary types.</p>
<h4><a class="anchor" id="autotoc_md4"></a>
__CPROVER_printf</h4>
<p><code>C void __CPROVER_printf(const char *format, ...);</code></p>
<p>The function **__CPROVER_printf** implements the C <code>printf</code> function (without any return value). The observable effect is that its output is shown within a counterexample trace.</p>
<h4><a class="anchor" id="autotoc_md5"></a>
__CPROVER_cover</h4>
<p><code>C void __CPROVER_cover(_Bool condition);</code></p>
<p>This statement defines a custom coverage criterion, for usage with the <a class="el" href="md_test-suite.html">test suite generation feature</a>.</p>
<h4><a class="anchor" id="autotoc_md6"></a>
__CPROVER_isnan, __CPROVER_isfinite, __CPROVER_isinf, __CPROVER_isnormal, __CPROVER_sign</h4>
<p><code>C _Bool __CPROVER_isnan(double f); _Bool __CPROVER_isfinite(double f); _Bool __CPROVER_isinf(double f); _Bool __CPROVER_isnormal(double f); _Bool __CPROVER_sign(double f);</code></p>
<p>The function **__CPROVER_isnan** returns true if the double-precision floating-point number passed as argument is a <a href="http://en.wikipedia.org/wiki/NaN">NaN</a>.</p>
<p>The function **__CPROVER_isfinite** returns true if the double-precision floating-point number passed as argument is a finite number.</p>
<p>This function **__CPROVER_isinf** returns true if the double-precision floating-point number passed as argument is plus or minus infinity.</p>
<p>The function **__CPROVER_isnormal** returns true if the double-precision floating-point number passed as argument is a normal number.</p>
<p>This function **__CPROVER_sign** returns true if the double-precision floating-point number passed as argument is negative.</p>
<h4><a class="anchor" id="autotoc_md7"></a>
__CPROVER_abs, __CPROVER_labs, __CPROVER_fabs, __CPROVER_fabsl, __CPROVER_fabsf</h4>
<p><code>C int __CPROVER_abs(int x); long int __CPROVER_labs(long int x); double __CPROVER_fabs(double x); long double __CPROVER_fabsl(long double x); float __CPROVER_fabsf(float x);</code></p>
<p>These functions return the absolute value of the given argument.</p>
<h4><a class="anchor" id="autotoc_md8"></a>
__CPROVER_overflow_minus, __CPROVER_overflow_mult, __CPROVER_overflow_plus, __CPROVER_overflow_shl, __CPROVER_overflow_unary_minus</h4>
<p><code>C __CPROVER_bool __CPROVER_overflow_minus(); __CPROVER_bool __CPROVER_overflow_mult(); __CPROVER_bool __CPROVER_overflow_plus(); __CPROVER_bool __CPROVER_overflow_shl(); __CPROVER_bool __CPROVER_overflow_unary_minus();</code></p>
<p>These functions take two (<code>__CPROVER_overflow_unary_minus</code> only takes one) arguments of any numeric type. They return true, if, and only if, the named operation would overflow when applied to the arguments. For example, <code>__CPROVER_overflow_plus(x, y)</code> returns true if <code>x + y</code> would result in an arithmetic overflow.</p>
<h4><a class="anchor" id="autotoc_md9"></a>
__CPROVER_array_equal, __CPROVER_array_copy, __CPROVER_array_set</h4>
<p><code>C _Bool __CPROVER_array_equal(const void array1[], const void array2[]); void __CPROVER_array_copy(const void dest[], const void src[]); void __CPROVER_array_set(const void dest[], value);</code></p>
<p>The function **__CPROVER_array_equal** returns true if the values stored in the given arrays are equal. The function **__CPROVER_array_copy** copies the contents of the array <b>src</b> to the array <b>dest</b>. The function **__CPROVER_array_set** initializes the array <b>dest</b> with the given value.</p>
<h4><a class="anchor" id="autotoc_md10"></a>
__CPROVER_enum_is_in_range</h4>
<p><code>C __CPROVER_bool __CPROVER_enum_is_in_range();</code></p>
<p>The function **__CPROVER_enum_is_in_range** is used to check that an enumeration has one of the defined enumeration values. In the following example <code>__CPROVER_enum_is_in_range(ev1)</code> will return true and the assertion will pass ```C enum my_enum { first, second };</p>
<p>int main() { enum my_enum ev1 = second; assert(__CPROVER_enum_is_in_range(ev1)); } <code>However, in the example below the assertion will fail</code>C enum my_enum { first, second };</p>
<p>int main() { enum my_enum ev1 = second + 1; assert(__CPROVER_enum_is_in_range(ev1)); } ```</p>
<h4><a class="anchor" id="autotoc_md11"></a>
Uninterpreted Functions</h4>
<p>Uninterpreted functions are documented <a class="el" href="md_modeling-nondeterminism.html">here</a>).</p>
<h3><a class="anchor" id="autotoc_md12"></a>
Memory-Related Functions</h3>
<p>The semantics of the primitives listed in this section is described in more detail in the document about <a class="el" href="md_memory-primitives.html">Memory Primitives</a>.</p>
<h4><a class="anchor" id="autotoc_md13"></a>
__CPROVER_POINTER_OBJECT, __CPROVER_POINTER_OFFSET, __CPROVER_same_object</h4>
<p><code>C __CPROVER_size_t __CPROVER_POINTER_OBJECT(const void *p); __CPROVER_ssize_t __CPROVER_POINTER_OFFSET(const void *p); _Bool __CPROVER_same_object(const void *p, const void *q);</code></p>
<p>The function **__CPROVER_POINTER_OBJECT** returns the ID of the object the pointer points to. The function **__CPROVER_POINTER_OFFSET** returns the offset of the given pointer relative to the base address of the object. The function **__CPROVER_same_object** returns true if the two pointers given as arguments point to the same object.</p>
<h4><a class="anchor" id="autotoc_md14"></a>
__CPROVER_OBJECT_SIZE, __CPROVER_DYNAMIC_OBJECT, __CPROVER_r_ok, __CPROVER_w_ok</h4>
<p>The following primitives require a pointer that is null or valid in order to have well-defined semantics in all usage cases. See the document about <a class="el" href="md_memory-primitives.html">Memory Primitives</a> for more details. It also includes a description of the <code>--pointer-primitive-check</code> option to verify the preconditions of the primitives.</p>
<p><code>C __CPROVER_size_t __CPROVER_OBJECT_SIZE(const void *p); _Bool __CPROVER_DYNAMIC_OBJECT(const void *p); void __CPROVER_r_ok(const T *p); void __CPROVER_r_ok(const void *p, size_t size); void __CPROVER_w_ok(const T *p); void __CPROVER_w_ok(const void *p, size_t size); void __CPROVER_rw_ok(const T *p); void __CPROVER_rw_ok(const void *p, size_t size);</code></p>
<p>The function **__CPROVER__OBJECT_SIZE** returns the size of the object the given pointer points to. The function **__CPROVER_DYNAMIC_OBJECT** returns true if the pointer passed as an argument points to a dynamically allocated object.</p>
<p>The function **__CPROVER_r_ok** returns true if reading the piece of memory starting at the given pointer with the given size is safe. **__CPROVER_w_ok** does the same with writing, and **__CPROVER_rw_ok** returns true when it is safe to do both. These predicates can be given an optional size; when the size argument is not given, the size of the subtype (which must not be <b>void</b>) of the pointer type is used.</p>
<h4><a class="anchor" id="autotoc_md15"></a>
__CPROVER_havoc_object</h4>
<p>This function requires a valid pointer and updates <b>all bytes</b> of the underlying object with nondeterministic values.</p>
<p><code>C void __CPROVER_havoc_object(void *p);</code></p>
<p><b>Warning</b></p>
<p>This primitive havocs object bytes before the given <code>p</code> and after <code>p + sizeof(*p)</code>:</p>
<p>```C struct foo { int x; int y; int z; };</p>
<p>struct foo thefoo = {.x = 1; .y = 2, .z = 3};</p>
<p>int* p = &amp;thefoo.y; // pointing to thefoo.y</p>
<p>__CPROVER_havoc_object(p); // makes the whole struct nondet __CPROVER_assert(thefoo.x == 1, "fails because `thefoo.x` is now nondet"); __CPROVER_assert(thefoo.y == 2, "fails because `thefoo.y` is now nondet"); __CPROVER_assert(thefoo.z == 3, "fails because `thefoo.z` is now nondet"); ```</p>
<h4><a class="anchor" id="autotoc_md16"></a>
__CPROVER_havoc_slice</h4>
<p>This function requires requires that <code>__CPROVER_w_ok(p, size)</code> holds, and updates <code>size</code> consecutive bytes of the underlying object, starting at <code>p</code>, with nondeterministic values.</p>
<p><code>C void __CPROVER_havoc_slice(void *p, __CPROVER_size_t size);</code></p>
<p><b>Caveat</b></p>
<ul>
<li>If the slice contains bytes that can be interpreted as pointers by the program, this will cause these pointers to become invalid (i.e. they will not point to anything meaningful).</li>
<li>If this slice only contains bytes that are not interpreted as pointers by the program, then havocing the slice is equivalent to making the interpretation of these bytes nondeterministic.</li>
</ul>
<h3><a class="anchor" id="autotoc_md17"></a>
Predefined Types and Symbols</h3>
<h4><a class="anchor" id="autotoc_md18"></a>
__CPROVER_bitvector</h4>
<p><code>C __CPROVER_bitvector [ expression ]</code></p>
<p>This type is only available in the C frontend. It is used to specify a bit vector with arbitrary but fixed size. The usual integer type modifiers <b>signed</b> and <b>unsigned</b> can be applied. The usual arithmetic promotions will be applied to operands of this type.</p>
<h4><a class="anchor" id="autotoc_md19"></a>
__CPROVER_floatbv</h4>
<p><code>C __CPROVER_floatbv [ expression ] [ expression ]</code></p>
<p>This type is only available in the C frontend. It is used to specify an IEEE-754 floating point number with arbitrary but fixed size. The first parameter is the total size (in bits) of the number, and the second is the size (in bits) of the mantissa, or significand (not including the hidden bit, thus for single precision this should be 23).</p>
<h4><a class="anchor" id="autotoc_md20"></a>
__CPROVER_fixedbv</h4>
<p><code>C __CPROVER_fixedbv [ expression ] [ expression ]</code></p>
<p>This type is only available in the C frontend. It is used to specify a fixed-point bit vector with arbitrary but fixed size. The first parameter is the total size (in bits) of the type, and the second is the number of bits after the radix point.</p>
<h4><a class="anchor" id="autotoc_md21"></a>
__CPROVER_size_t</h4>
<p>The type of sizeof expressions.</p>
<h4><a class="anchor" id="autotoc_md22"></a>
__CPROVER_rounding_mode</h4>
<p><code>C extern int __CPROVER_rounding_mode;</code></p>
<p>This variable contains the IEEE floating-point arithmetic rounding mode.</p>
<h4><a class="anchor" id="autotoc_md23"></a>
__CPROVER_constant_infinity_uint</h4>
<p>This is a constant that models a large unsigned integer.</p>
<h4><a class="anchor" id="autotoc_md24"></a>
__CPROVER_integer, __CPROVER_rational</h4>
<p>**__CPROVER_integer** is an unbounded, signed integer type. **__CPROVER_rational** is an unbounded, signed rational number type.</p>
<h4><a class="anchor" id="autotoc_md25"></a>
__CPROVER_memory</h4>
<p><code>C extern unsigned char __CPROVER_memory[];</code></p>
<p>This array models the contents of integer-addressed memory.</p>
<h4><a class="anchor" id="autotoc_md26"></a>
__CPROVER::unsignedbv&lt;N&gt; (C++ only)</h4>
<p>This type is the equivalent of <b>unsigned __CPROVER_bitvector[N]</b> in the C++ front-end.</p>
<h4><a class="anchor" id="autotoc_md27"></a>
__CPROVER::signedbv&lt;N&gt; (C++ only)</h4>
<p>This type is the equivalent of <b>signed __CPROVER_bitvector[N]</b> in the C++ front-end.</p>
<h4><a class="anchor" id="autotoc_md28"></a>
__CPROVER::fixedbv&lt;N&gt; (C++ only)</h4>
<p>This type is the equivalent of **__CPROVER_fixedbv[N,m]** in the C++ front-end.</p>
<h3><a class="anchor" id="autotoc_md29"></a>
Concurrency</h3>
<p>Asynchronous threads are created by preceding an instruction with a label with the prefix **__CPROVER_ASYNC_**.</p>
<p>Last modified: 2022-09-21 19:02:04 -0400 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
