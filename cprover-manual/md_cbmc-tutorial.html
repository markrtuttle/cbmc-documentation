<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CProver manual: cbmc-tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CProver manual
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">cbmc-tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href=".">CPROVER Manual TOC</a></p>
<h3><a class="anchor" id="autotoc_md31"></a>
Example: Buffer Overflows</h3>
<p>To give a brief overview of the capabilities of CBMC we start with a simple example. The issue of <em><a href="http://en.wikipedia.org/wiki/Buffer_overflow">buffer overflows</a></em> has obtained wide public attention. A buffer is a contiguously allocated chunk of memory, represented by an array or a pointer in C. Programs written in C do not provide automatic bounds checking on the buffer, which means a program can – accidentally or deliberately – write beyond a buffer. The following example is a perfectly valid C program (in the sense that a compiler compiles it without any errors):</p>
<p><code>C int main() { int buffer[10]; buffer[20] = 10; }</code></p>
<p>However, the write access to an address outside the allocated memory region can lead to unexpected behavior. In particular, such bugs can be exploited to overwrite the return address of a function, thus enabling the execution of arbitrary user-induced code. CBMC is able to detect this problem and reports that the "upper bound property" of the buffer has been violated. CBMC is capable of checking these lower and upper bounds, even for arrays with dynamic size. A detailed discussion of the properties that CBMC can check automatically is <a class="el" href="md_properties.html">here</a>.</p>
<h3><a class="anchor" id="autotoc_md32"></a>
First Steps</h3>
<p>We assume you have already installed CBMC and the necessary support files on your system. If not so, please follow the instructions <a class="el" href="md_installation.html">here</a>.</p>
<p>Like a compiler, CBMC takes the names of .c files as command line arguments. CBMC then translates the program and merges the function definitions from the various .c files, just like a linker. But instead of producing a binary for execution, CBMC performs symbolic simulation on the program.</p>
<p>As an example, consider the following simple program, named <a href="file1.c">file1.c</a>:</p>
<p>```C int puts(const char *s) { }</p>
<p>int main(int argc, char **argv) { puts(argv[2]); return 0; } ```</p>
<p>Of course, this program is faulty, as the <code>argv</code> array might have fewer than three elements, and then the array access <code>argv[2]</code> is out of bounds. Now, run CBMC:</p>
<p><code>cbmc file1.c --show-properties --bounds-check --pointer-check</code></p>
<p>The two options <code>--bounds-check</code> and <code>--pointer-check</code> instruct CBMC to look for errors related to pointers and array bounds. CBMC will print the list of properties it checks. Note that it lists, among others, a property labelled with "pointer outside object bounds in argv" together with the location of the faulty array access. As you can see, CBMC largely determines the property it needs to check itself. This is realized by means of a preliminary static analysis, which relies on computing a fixed point on various <a href="http://en.wikipedia.org/wiki/Abstract_interpretation">abstract domains</a>. More detail on automatically generated properties is provided <a class="el" href="md_properties.html">here</a>.</p>
<p>Note that these automatically generated properties need not necessarily correspond to bugs – these are just <em>potential</em> flaws, as abstract interpretation might be imprecise. Whether these properties hold or correspond to actual bugs needs to be determined by further analysis.</p>
<p>CBMC performs this analysis using <em>symbolic simulation</em>, which corresponds to a translation of the program into a formula. The formula is then combined with the property. Let's look at the formula that is generated by CBMC's symbolic simulation:</p>
<p><code>cbmc file1.c --show-vcc --bounds-check --pointer-check</code></p>
<p>With this option, CBMC performs the symbolic simulation and prints the verification conditions on the screen. A verification condition needs to be proven to be valid by a <a href="http://en.wikipedia.org/wiki/Decision_problem">decision procedure</a> in order to assert that the corresponding property holds. Let's run the decision procedure:</p>
<p><code>cbmc file1.c --bounds-check --pointer-check</code></p>
<p>CBMC transforms the equation you have seen before into CNF and passes it to a SAT solver (more background on this step is in the book on <a href="http://www.decision-procedures.org/">Decision Procedures</a>). It then determines which of the properties that it has generated for the program hold and which do not. Using the SAT solver, CBMC detects that the property for the object bounds of <code>argv</code> does not hold, and will display:</p>
<p><code>plaintext [main.pointer_dereference.6] line 7 dereference failure: pointer outside object bounds in argv[(signed long int)2]: FAILURE</code></p>
<h3><a class="anchor" id="autotoc_md33"></a>
Counterexample Traces</h3>
<p>Let us have a closer look at this property and why it fails. To aid the understanding of the problem, CBMC can generate a <em>counterexample trace</em> for failed properties. To obtain this trace, run: </p><pre class="fragment">cbmc file1.c --bounds-check --pointer-check --trace
</pre><p>CBMC then prints a counterexample trace, that is, a program trace that begins with <code>main</code> and ends in a state which violates the property. In our example, the program trace ends in the faulty array access. It also gives the values the input variables must have for the bug to occur. In this example, <code>argc</code> must be one to trigger the out-of-bounds array access. If you add a branch to the example that requires that <code>argc&gt;=3</code>, the bug is fixed and CBMC will report that the proofs of all properties have been successful.</p>
<p>To simplify further processing of counterexample traces, CBMC supports XML as a possible output format.</p>
<p><code>cbmc file1.c --bounds-check --pointer-check --trace --xml-ui</code></p>
<h3><a class="anchor" id="autotoc_md34"></a>
Verifying Modules</h3>
<p>In the example above, we used a program that starts with a <code>main</code> function. However, CBMC is aimed at embedded software, and these kinds of programs usually have different entry points. Furthermore, CBMC is also useful for verifying program modules. Consider the following example, called <a href="file2.c">file2.c</a>:</p>
<p>```C int array[10];</p>
<p>int sum() { unsigned i, sum;</p>
<p>sum = 0; for(i = 0; i &lt; 10; i++) sum += array[i];</p>
<p>return sum; } ```</p>
<p>To set the entry point to the <code>sum</code> function, run:</p>
<p><code>plaintext cbmc file2.c --function sum --bounds-check</code></p>
<p>It is often necessary to build a suitable <em>harness</em> for the function in order to set up the environment appropriately.</p>
<h3><a class="anchor" id="autotoc_md35"></a>
Loop Unwinding</h3>
<p>When running the previous example, you will have noted that CBMC unwinds the <code>for</code> loop in the program. As CBMC performs Bounded Model Checking, all loops have to have a finite upper run-time bound in order to guarantee that all bugs are found. CBMC can optionally check that enough unwinding is performed. As an example, consider the program <a href="binsearch.c">binsearch.c</a>:</p>
<p>```C int binsearch(int x) { int a[16]; signed low = 0, high = 16;</p>
<p>while(low &lt; high) { signed middle = low + ((high - low) &gt;&gt; 1); </p><pre class="fragment">if(a[middle] &lt; x)
  high = middle;
else if(a[middle] &gt; x)
  low = middle + 1;
else // a[middle]==x
  return middle;
</pre><p>}</p>
<p>return -1; } ```</p>
<p>If you run CBMC on this function, you will notice that the unwinding does not stop on its own. The built-in simplifier is not able to determine a run time bound for this loop. The unwinding bound has to be given as a command line argument:</p>
<p><code>plaintext cbmc binsearch.c --function binsearch --unwind 6 --bounds-check --unwinding-assertions</code></p>
<p>CBMC verifies that the array accesses are within the bounds; note that this actually depends on the result of the right shift. In addition, as CBMC is given the option <code>--unwinding-assertions</code>, it also checks that enough unwinding is done, i.e., it proves a run-time bound. For any lower unwinding bound, there are traces that require more loop iterations. Thus, CBMC will report that the unwinding assertion has failed. As usual, a counterexample trace that documents this can be obtained with the option <code>--property</code>.</p>
<h3><a class="anchor" id="autotoc_md36"></a>
Unbounded Loops</h3>
<p>CBMC can also be used for programs with unbounded loops. In this case, CBMC is used for bug hunting only; CBMC does not attempt to find all bugs. The following program (<a href="lock-example.c">lock-example.c</a>) is an example of a program with a user-specified property:</p>
<p>```C _Bool nondet_bool(); unsigned int nondet_unsigned_int(); _Bool LOCK = 0;</p>
<p>_Bool lock() { if(nondet_bool()) { assert(!LOCK); LOCK = 1; return 1; }</p>
<p>return 0; }</p>
<p>void unlock() { assert(LOCK); LOCK = 0; }</p>
<p>int main() { unsigned got_lock = 0; unsigned times = nondet_unsigned_int();</p>
<p>while(times &gt; 0) { if(lock()) { got_lock++; /* critical section */ } </p><pre class="fragment">if(got_lock != 0)
  unlock();

got_lock--;
times--;
</pre><p>} } ```</p>
<p>The <code>while</code> loop in the <code>main</code> function has no (useful) run-time bound. Thus, a bound has to be set on the amount of unwinding that CBMC performs. There are two ways to do so:</p>
<ol type="1">
<li>The <code>--unwind</code> command-line parameter can to be used to limit the number of times loops are unwound.</li>
<li>The <code>--depth</code> command-line parameter can be used to limit the number of program steps to be processed.</li>
</ol>
<p>Given the option <code>--unwinding-assertions</code>, CBMC checks whether the argument to <code>--unwind</code> is large enough to cover all program paths. If the argument is too small, CBMC will detect that not enough unwinding is done reports that an unwinding assertion has failed.</p>
<p>Reconsider the example. For a loop unwinding bound of one, no bug is found. But for a bound of two, CBMC detects a trace that violates an assertion. Without unwinding assertions, or when using the <code>--depth</code> command line switch, CBMC does not prove the program correct, but it can be helpful to find program bugs. The various command line options that CBMC offers for loop unwinding are described in the section on <a class="el" href="md_cbmc-unwinding.html">understanding loop unwinding</a>.</p>
<h3><a class="anchor" id="autotoc_md37"></a>
A Note About Compilers and the ANSI-C Library</h3>
<p>Most C programs make use of functions provided by a library; instances are functions from the standard ANSI-C library such as <code>malloc</code> or <code>printf</code>. The verification of programs that use such functions has two requirements:</p>
<ol type="1">
<li>Appropriate header files have to be provided. These header files contain <em>declarations</em> of the functions that are to be used.</li>
<li>Appropriate <em>definitions</em> have to be provided.</li>
</ol>
<p>Most C compilers come with header files for the ANSI C library functions. We briefly discuss how to obtain/install these library files.</p>
<h4><a class="anchor" id="autotoc_md38"></a>
Linux</h4>
<p>Linux systems that are able to compile software are usually equipped with the appropriate header files. Consult the documentation of your distribution on how to install the compiler and the header files. First try to compile some significant program before attempting to verify it.</p>
<h4><a class="anchor" id="autotoc_md39"></a>
Windows</h4>
<p>On Microsoft Windows, CBMC is pre-configured to use the compiler that is part of Microsoft's Visual Studio. Microsoft's <a href="http://www.visualstudio.com/en-us/products/visual-studio-community-vs">Visual Studio Community</a> is fully featured and available for download for free from the Microsoft webpage. Visual Studio installs the usual set of header files together with the compiler. However, the Visual Studio compiler requires a large set of environment variables to function correctly. It is therefore required to run CBMC from the <em>Visual Studio Command Prompt</em>, which can be found in the menu <em>Visual Studio Tools</em>.</p>
<p>Note that in both cases, only header files are available. CBMC only comes with a small set of definitions, which includes functions such as <code>malloc</code>. Detailed information about the built-in definitions is <a class="el" href="md_goto-cc.html">here</a>.</p>
<h3><a class="anchor" id="autotoc_md40"></a>
Further Reading</h3>
<ul>
<li>Understanding Loop Unwinding</li>
<li><a href="http://www-2.cs.cmu.edu/~svc/papers/view-publications-ck03.html">Hardware Verification using ANSI-C Programs as a Reference</a></li>
<li><a href="http://www-2.cs.cmu.edu/~svc/papers/view-publications-cky03.html">Behavioral Consistency of C and Verilog Programs Using Bounded Model Checking</a></li>
<li><a href="http://www-2.cs.cmu.edu/~svc/papers/view-publications-ckl2004.html">A Tool for Checking ANSI-C Programs</a></li>
</ul>
<p>We also have a <a href="http://www.cprover.org/cbmc/applications/">list of interesting applications of CBMC</a>.</p>
<p>Last modified: 2022-09-21 19:02:04 -0400 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
